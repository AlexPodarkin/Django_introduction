from django.contrib import admin
from .models import Category, Product, Client, ProductAdmin


@admin.action(description='Сбросить кол-во в ноль')
def reset_quantity(modeladmin, request, queryset):
    """Добавление новых действий"""
    queryset.update(quantity=0)
    # Создаём функцию reset_quantity, которая принимает три обязательных параметра:
    # модель админа, запрос и объект запроса в базу данных queryset. Для функции
    # прописываем декоратор @admin.action. Так Django поймёт, что мы создали новое
    # действие. В качестве аргумента декоратора передаём текст, который будет виден в
    # раскрывающемся списке действий. Сама функция использует объект queryset, для
    # того чтобы обновить количество товара, установив в качестве значения ноль.
    # Чтобы действие появилось в списке возможных, !!! прописываем у административной модели переменную actions.!!!
    # actions = [reset_quantity] В список складываем добавляемые действия.


class ProductAdminAdmin(admin.ModelAdmin):

    # Отображение дополнительных полей (не только __str__, мы можем это редактировать)
    list_display = ['name', 'category', 'quantity']
    # Переменная list_display является зарезервированным именем. Django
    # автоматически найдёт её и прочитает содержимое списка. Как вы догадались, в
    # списке имена полей модели Продукты. Помимо имени мы хотим видеть категорию
    # продукта и сколько его осталось на складе

    # Сортировка строк
    ordering = ['category', '-quantity']
    # Переменная ordering так же является зарезервированным именем. Django
    # автоматически найдёт её и прочитает содержимое списка. В нашем примере
    # используется двухуровневая сортировка продуктов. Вначале по категориям по
    # возрастанию первичного ключа, далее по количеству по убыванию внутри категории.
    # Внимание! Сортировка таблиц базы данных с большим количеством
    # значений может значительно замедлить выполнение запроса. Если
    # сортируются не индексированные поля, скорость также снижается. Не
    # стоит злоупотреблять сортировкой данных!

    # Добавление фильтрации в список изменения
    list_filter = ['date_added', 'price']
    # В админке, Справа от списка изменений появился раздел Фильтр с двумя блоками: дата
    # добавления и цена. При этом модель адаптируется под тип поля и его содержимое.
    # Для даты видим возможность фильтрации

    # Текстовый поиск
    search_fields = ['description']
    search_help_text = 'Поиск по полю: Описание продукта(description)'
    # Список search_fields определяет по каким полям будет проходить поиск текста. В
    # нашем примере мы ищем совпадение введённой строк со значениями поля
    # description. Тут же можно указать подсказку по поиску. Для этого используем
    # переменную search_help_text.

    actions = [reset_quantity]
    # actions = [reset_quantity] нужно для работы функции reset_quantity!

    # Отображение полей
    # отображение продукта (убрали цену и количество, добавили отображение даты НЕСОВМЕСТИМ С fieldsets ниже!)
    # fields = ['name', 'description', 'category', 'date_added', 'rating']
    # Новое поле fields определяет порядок вывода элементов формы. Если опустить
    # какие-то поля, они перестанут отображаться. Например, мы больше не видим цену и
    # количество товара(раскомментировать fields).

    readonly_fields = ['date_added', 'rating']
    # Переменная readonly_fields так же содержит список полей. Эти поля можно
    # просматривать, но нельзя изменять. Мы сделали неизменяемым рейтинг. Поле
    # 'date_added' изначально было неизменяемым, так как дата проставляется
    # автоматически в момент создания записи. Подобное поведение мы указали в модели
    # Если добавить дату добавления в fields, но не добавлять в readonly_fields, получим
    # ошибку вида FieldError:
    # !!! Будьте внимательны при выводе полей. Редактируемое поле можно сделать
    # не редактируемым, добавив в readonly_fields список. Наоборот сделать не получится.

    # Детальная настройка отображения полей
    fieldsets = [
        # Все поля будут разбиты на четыре группы (fieldset)
        (
            None,
            {
                'classes': ['wide'],
                'fields': ['name'],
                # Первая группа будет содержать только поле "name", она будет иметь
                # класс "wide", что означает, что она будет занимать все доступное место
                # на странице.
            },
        ),
        (
            'Подробности',
            {
                'classes': ['collapse'],
                'description': 'Категория товара и его подробное описание',
                'fields': ['category', 'description'],
                # Вторая группа будет содержать поля "category" и "description", они
                # будут скрыты по умолчанию (класс "collapse"), но можно будет
                # развернуть эту группу, нажав на соответствующий заголовок. Под
                # заголовком отобразится описание группы
            },
        ),
        (
            'Бухгалтерия',
            {
                'fields': ['price', 'quantity'],
                # Третья группа будет содержать поля "price" и "quantity". Они выводятся
                # в одну строку, потому что переданы как элемент кортежа.

            }
        ),
        (
            'Рейтинг и прочее',
            {
                'description': 'Рейтинг сформирован автоматически на основе оценок покупателей',
                'fields': ['rating', 'date_added'],
                # Четвертая группа будет содержать поля "rating" и "date_added", она
                # также содержит описание, которое будет отображаться под заголовком
                # Поля "date_added" и "rating" отобразятся только для чтения, так как они будут
                # указаны в параметре readonly_fields.
            }
        ),
    ]


# Подключение моделей к административной панели (не забываем делать импорты моделей)
admin.site.register(Category)
admin.site.register(ProductAdmin, ProductAdminAdmin)
admin.site.register(Client)
admin.site.register(Product)
# Кстати это делается в первую очередь!
